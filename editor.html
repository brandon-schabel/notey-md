<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Editing Note</title> <!-- Note name will be set dynamically -->
    <style>
        body {
            font-family: sans-serif;
            margin: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .editor-container {
            display: flex;
            gap: 1rem;
        }
        textarea {
            width: 50%;
            height: 70vh;
            font-family: monospace;
            font-size: 1rem;
            line-height: 1.4;
        }
        #preview {
            width: 50%;
            border-left: 1px solid #ccc;
            padding-left: 1rem;
            overflow-y: auto;
            height: 70vh;
        }
        code.inline {
            background-color: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
        }
        pre {
            background-color: #f2f2f2;
            padding: 1rem;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #333;
            margin-top: 1rem;
        }
        strong {
            font-weight: bold;
        }
        em {
            font-style: italic;
        }
        .toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .toolbar button {
            cursor: pointer;
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
        }
        .status-message {
            color: green;
            font-size: 0.9rem;
            margin-left: 1rem;
        }
    </style>
</head>
<body>
    <h1>Editing Note: <span id="note-name-display"></span></h1>
    <div class="toolbar">
        <button id="saveBtn">Save</button>
        <button id="boldBtn">Bold</button>
        <button id="italicBtn">Italic</button>
        <button id="codeBtn">Inline Code</button>
        <span class="status-message" id="statusMsg"></span>
    </div>
    <div class="editor-container">
        <textarea id="editor"></textarea>
        <div id="preview"></div>
    </div>

    <script>
        // This small script *initializes* the editor with data from the server.
        // The server will set these data attributes on the relevant elements.
        function initEditor(noteName, initialContent) {
            const editorEl = document.getElementById("editor");
            const previewEl = document.getElementById("preview");
            const statusMsg = document.getElementById("statusMsg");
            const saveBtn = document.getElementById("saveBtn");
            const boldBtn = document.getElementById("boldBtn");
            const italicBtn = document.getElementById("italicBtn");
            const codeBtn = document.getElementById("codeBtn");
            const noteNameDisplay = document.getElementById("note-name-display");

            let autosaveTimer = null;
            let isSaving = false;

            // Set initial content and note name
            editorEl.value = initialContent;
            noteNameDisplay.textContent = noteName;
            updatePreview(); // Initial render


            // Event Listeners
            editorEl.addEventListener("input", () => {
                updatePreview();
                scheduleAutosave();
            });

            saveBtn.addEventListener("click", doAutosave);
            boldBtn.addEventListener("click", () => applyWrappedFormat("**"));
            italicBtn.addEventListener("click", () => applyWrappedFormat("*"));
            codeBtn.addEventListener("click", () => applyWrappedFormat("`"));

            // --- Function Definitions (organized for clarity and future extraction) ---

            function updatePreview() {
                const md = editorEl.value;
                previewEl.innerHTML = naiveClientMarkdownRender(md);
            }

            function scheduleAutosave() {
                if (isSaving) return;
                if (autosaveTimer) clearTimeout(autosaveTimer);
                autosaveTimer = setTimeout(doAutosave, 1500); // 1.5s delay
            }

            function doAutosave() {
                if (isSaving) return;
                isSaving = true;
                const content = editorEl.value;
                fetch("/notes/save", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ filename: noteName, content })
                })
                .then(resp => resp.text())
                .then(text => {
                    statusMsg.innerText = "AutoSaved at " + new Date().toLocaleTimeString();
                    setTimeout(() => { statusMsg.innerText = ""; }, 3000);
                })
                .catch(err => {
                    console.error("Autosave error:", err);
                    statusMsg.innerText = "Save failed!";
                })
                .finally(() => { isSaving = false; });
            }

            function applyWrappedFormat(wrapper) {
                const start = editorEl.selectionStart;
                const end = editorEl.selectionEnd;
                const text = editorEl.value;

                if (start === end) {
                    const newText = text.slice(0, start) + wrapper + wrapper + text.slice(end);
                    editorEl.value = newText;
                    editorEl.selectionStart = editorEl.selectionEnd = start + wrapper.length;
                } else {
                    const selectedText = text.slice(start, end);
                    const newText = text.slice(0, start) + wrapper + selectedText + wrapper + text.slice(end);
                    editorEl.value = newText;
                    editorEl.selectionStart = start + wrapper.length;
                    editorEl.selectionEnd = end + wrapper.length;
                }
                updatePreview();
                scheduleAutosave();
            }

            function naiveClientMarkdownRender(markdown) {
                const escaped = markdown
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");

                let result = escaped
                    .replace(/`([^`]+)`/g, '<code class="inline">$1</code>')
                    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*([^*]+)\*/g, '<em>$1</em>');

                result = result.replace(/^### (.*)$/gm, "<h3>$1</h3>");
                result = result.replace(/^## (.*)$/gm, "<h2>$1</h2>");
                result = result.replace(/^# (.*)$/gm, "<h1>$1</h1>");

                const paragraphs = result.split(/\n\n/g).map(p => {
                    if (p.match(/<h[1-3]>/)) {
                        return p;
                    }
                    return "<p>" + p.replace(/\n/g, "<br>") + "</p>";
                });

                return paragraphs.join("\n");
            }
        }

        // Call initEditor with placeholders.  The server will replace these.
        initEditor("NOTE_NAME_PLACEHOLDER", "INITIAL_CONTENT_PLACEHOLDER");
    </script>
</body>
</html> 